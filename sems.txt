
Domains
=============================================================

Program Value 
	PV : all values usable by the conventional programming 
	
Program Function
	F: [PV] -> PV
	A function over normal program values
	
	
Neant
	NA: null equivalent for signals

Value
	V = V || NA
	
Time
	T : {0,1,2,...}

Signal
	S: T -> V
	a value that varies over time

Continuous Signal (Property)
	P: T -> PV
	a signal function defined for all values of T, always produces a non NA value
	

Operators
==========

there are 2 types of operations:

1- Those who can act on the program clock -> can be viewed as operations on sets (note that this implies a push based approach on the semantic model)
2- Those who act on the signal values -> can be viewed as functions

1- Stream operators
---------------------

or: [S] -> T -> V
or( [s], t ) = first ( si != NA )(t) || NA

and: [S] -> T -> V
and( [s] ) = all( [si != NA ) => [si] || NA

filter: F -> [S] -> T -> V
filter (f, [s], t ) = f( [s(t)] ) => [s(t)] || NA 

2- Signal functions
--------------------

keep: S -> T -> V
keep(s, t) = s(t) != NA => s(t)
		else    => s(t-1)

map: F -> [S] -> T -> V
map (f, [s], t) = all([s(t)]) != NA  && f([s(t)])  || NA

switch: S -> T -> V
switch(s, t) = s(t)(t)

scan: F -> PV -> S -> T -> PV
scan (f, v, s, t) = s(t) == NA => v || f(v, s(t))
			
join: [S] -> T -> V
join ([s], t) = [keep(si, t)] if [ki] != NA else NA
