
Domains
=============================================================

Program Value 
	PV : all values usable by the conventional programming 
	
Program Function
	F: [PV] -> PV
	A function over normal program values
	
	
Neant
	NA: null equivalent for signals

Value
	V = V || NA
	
Time
	T : [t0, t1, ...., tn]

Event
	E: [(T,PV)]

Signal
	S: T -> V
	a value that varies over time

Continuous Signal (Property)
	P: T -> PV
	a signal function defined for all values of T, always produces a non NA value
	

Operators
==========

there are 2 types of operations:

1- Those who can act on the program clock -> can be viewed as operations on sets (note that this implies a push based approach on the semantic model)
2- Those who act on the signal values -> can be viewed as functions

1- Stream operators
---------------------

or: [E] -> E
or( [Ei] ) = Union [Ei]

and: [E] -> E
and( [Ei] ) = Intersect [Ei]

filter: F -> [E] -> E
filter (f, [Ei] ) = [ e where e â‚¬ or([Ei]) && f(e(v) ) = true ]

2- Signal functions
--------------------

keep: S -> T -> V
keep(s, t) = s(t) != NA => s(t)
		else    => s(t-1)

map: F -> [S] -> T -> V
map (f, [s], t) = all([s(t)]) != NA  && f([s(t)])  || NA

switch: S -> T -> V
switch(e, t) = e(t)(t)

scan: F -> V -> S -> T -> V
scan (f, v, s, t) = s(t) == NA => v
			else   => f(v, s(t))
			
join: [S] -> T -> V
join ([s], t) = [ki] if [ki] != NA else NA
		  where
		     ki = keep(si, t)
